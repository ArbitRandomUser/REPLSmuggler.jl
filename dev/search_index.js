var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = REPLSmuggler","category":"page"},{"location":"#REPLSmuggler","page":"Home","title":"REPLSmuggler","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for REPLSmuggler.","category":"page"},{"location":"","page":"Home","title":"Home","text":"REPLSmuggler is meant to evaluate code coming from various clients in your REPL. The main goal is for an editor to send a bunch of lines of code with some metadata giving the name of the file and the line. REPLSmuggler will evaluate the code and send back the return value. If an error is raised, it will send the traceback to the client.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See also the the companion plugin for NeoVim.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Depth=5","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Using REPLSmuggler is as simple as:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using REPLSmugglers\njulia> smuggle()\n[ Info: Ahoy, now smuggling from socket /run/user/1000/julia/replsmuggler/contraband_clandestine_operation.\nTask (runnable) @0x0000753a784c6bd0","category":"page"},{"location":"#Internals","page":"Home","title":"Internals","text":"","category":"section"},{"location":"#REPLSmuggler-2","page":"Home","title":"REPLSmuggler","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [REPLSmuggler]","category":"page"},{"location":"#REPLSmuggler.CURRENT_SMUGGLER","page":"Home","title":"REPLSmuggler.CURRENT_SMUGGLER","text":"Store the current server.\n\n\n\n\n\n","category":"constant"},{"location":"#REPLSmuggler.smuggle-Tuple{Any, Any}","page":"Home","title":"REPLSmuggler.smuggle","text":"smuggle(smuggler, args...; kwargs...)\n\nYou can start smuggling.\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.smuggle-Tuple{}","page":"Home","title":"REPLSmuggler.smuggle","text":"smuggler()\n\nStart a server using a UNIX sockets with a random name and MsgPack.jl as a serializer.\n\nThe socket name is displayed in the REPL, and the server is accessible through CURRENT_SMUGGLER.\n\n\n\n\n\n","category":"method"},{"location":"#Protocol","page":"Home","title":"Protocol","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [REPLSmuggler.Protocols]","category":"page"},{"location":"#REPLSmuggler.Protocols","page":"Home","title":"REPLSmuggler.Protocols","text":"Definition of the protocol used by REPLSmuggler.jl. It is based on MsgPack-RPC, see here:\n\nhttps://github.com/msgpack/msgpack/blob/master/spec.md\nhttps://github.com/msgpack-rpc/msgpack-rpc/blob/master/spec.md\n\nThe actual (de)serialization from and to MsgPack objects is handled by MsgPack.jl through a lightweight wrapper defined in MsgPackSerializer.\n\nThe protocol consists of requests messages and their corresponding response messages. There can also be notification messages.\n\nAs per the specification, a request is serialized to an array of four elements, that could be written in Julia as follow:\n\n[type::UInt8, msgid::UInt32, method::String, params::Vector{Any}]\n\nWhere type = 0x00. For convenience, we define a structure and teach MsgPack.jl to serialize it.\n\nA response message should be serialized as:\n\n[type::UInt8, msgid::UInt32, error::Any, result::Any]\n\nWhere type = 0x01. msgid is the identifier of the corresponding request.\n\nFinally, a notification has the form:\n\n[type::UInt8, method::String, params::Vector{Any}]\n\nWhere type = 0x02.\n\nDefined methods for requests.\n\nWe allow the client to run the following methods. If a method is unknown by the server, it will raise an error.\n\neval: Evaluate a chunk of code. Parameters:\nfile::String\nline::UInt32\ncode::String\ninterrupt: Interrupt the current evaluation. No parameter.\nexit: Stop the current session. No parameter.\n\nResponses of the server.\n\nThe result field is a string of what would be printed in the REPL. It is empty if an error occured. \n\nIf an error occured, then the error field is a three-elements array structured as follow:\n\nexception::String: Name of the exception, e.g. \"ValueError\",\nexception_text::String: Text, e.g. \"This value cannot be < 0.\",\nstacktrace::Vector{Tuple{String, UInt32, String}}: The stacktrace, with each  row being (file, line, function).\n\nNotifications by the server.\n\nCurrently, the following notifications can be sent by the server. If a notification received by the client is unknown, it should simply be ignored without erroring.\n\nhandshake: Sent at the begining of a session, mainly to ensure the correct version of the protocol is being used. Parameters:\nmyname::String: Name of the server. Will typically be REPLSmuggler, but could be replaced if other implementations of the protocol were to exist.\nversion::String: A sementic versioning version number telling the client which version of the protocol is being used by the server.\n\nTypical session:\n\nThe client connects to the server.\nThe server sends a handshake notification.\nThe client checks it is running the correct version of the protocol.\nThe client runs requests (eval, interrupts...)\nThe server responds to the requests.\nThe client runs exit.\nThe server stops all the running code and close the session.\n\nNote that any interrupt of the connection (i.e. closing the socket) is equivalent to sending an exit request.\n\n\n\n\n\n","category":"module"},{"location":"#REPLSmuggler.Protocols.PROTOCOL_MAGIC","page":"Home","title":"REPLSmuggler.Protocols.PROTOCOL_MAGIC","text":"Name of the protocol implementation.\n\n\n\n\n\n","category":"constant"},{"location":"#REPLSmuggler.Protocols.PROTOCOL_VERSION","page":"Home","title":"REPLSmuggler.Protocols.PROTOCOL_VERSION","text":"Protocol version.\n\n\n\n\n\n","category":"constant"},{"location":"#REPLSmuggler.Protocols.AbstractMsgPackRPC","page":"Home","title":"REPLSmuggler.Protocols.AbstractMsgPackRPC","text":"Represents a MsgPackRPC message. type needs not to be stored explicitely.\n\n\n\n\n\n","category":"type"},{"location":"#REPLSmuggler.Protocols.AbstractResponse","page":"Home","title":"REPLSmuggler.Protocols.AbstractResponse","text":"Represents a response.\n\n\n\n\n\n","category":"type"},{"location":"#REPLSmuggler.Protocols.MsgType","page":"Home","title":"REPLSmuggler.Protocols.MsgType","text":"MsgPackRPC message types.\n\n\n\n\n\n","category":"type"},{"location":"#REPLSmuggler.Protocols.Notification","page":"Home","title":"REPLSmuggler.Protocols.Notification","text":"Represents a notification.\n\n\n\n\n\n","category":"type"},{"location":"#REPLSmuggler.Protocols.ProtocolException","page":"Home","title":"REPLSmuggler.Protocols.ProtocolException","text":"Used internally to report protocol exceptions.\n\n\n\n\n\n","category":"type"},{"location":"#REPLSmuggler.Protocols.Request","page":"Home","title":"REPLSmuggler.Protocols.Request","text":"Represents a request.\n\n\n\n\n\n","category":"type"},{"location":"#REPLSmuggler.Protocols.Error-Union{Tuple{T}, Tuple{Any, T, Any}} where T","page":"Home","title":"REPLSmuggler.Protocols.Error","text":"Error(msgid, error, stackframe)\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.Protocols.Handshake-Tuple{}","page":"Home","title":"REPLSmuggler.Protocols.Handshake","text":"Handshake()\n\nCreate a hand-shake notification.\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.Protocols.Result-Tuple{Any, Any}","page":"Home","title":"REPLSmuggler.Protocols.Result","text":"Result(msgid, result)\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.Protocols.astuple","page":"Home","title":"REPLSmuggler.Protocols.astuple","text":"astuple(message)\n\nReturns a vector from the message that can be serialized.\n\n\n\n\n\n","category":"function"},{"location":"#REPLSmuggler.Protocols.deserialize","page":"Home","title":"REPLSmuggler.Protocols.deserialize","text":"serialize(protocol)\n\nDe-serialize an AbstractMsgPackRPC. Must be implemented by the serializer, e.g. MsgPackSerializer.jl.\n\n\n\n\n\n","category":"function"},{"location":"#REPLSmuggler.Protocols.dispatchonmessage-Tuple{REPLSmuggler.Protocols.Protocol, Any, Vararg{Any}}","page":"Home","title":"REPLSmuggler.Protocols.dispatchonmessage","text":"dispatchonmessage(protocol, f, args...; kwargs)\n\nDeserialize a request, and send it to the correct method of f. f should define methods with a first parameter being of type Val{:method} where method can be: \"eval\", \"interrupt\", or \"exit\". f is called as:\n\nf(Val(method), args..., request.msgid, request.params...; kwargs...)\n\nA ProtocolException might be raised if the request is malformed.\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.Protocols.serialize","page":"Home","title":"REPLSmuggler.Protocols.serialize","text":"serialize(protocol, message)\n\nSerialize an AbstractMsgPackRPC. Must be implemented by the serializer, e.g. MsgPackSerializer.jl.\n\n\n\n\n\n","category":"function"},{"location":"#Server","page":"Home","title":"Server","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [REPLSmuggler.Server]","category":"page"},{"location":"#REPLSmuggler.Server","page":"Home","title":"REPLSmuggler.Server","text":"Implementation of the server for REPLSmuggler.jl -the brain of REPSmuggler.jl.\n\nThe handling of the communication protocol is done by Protocols.\n\nThe implementation is heavily inspired by the server from RemoteREPL.jl.\n\n\n\n\n\n","category":"module"},{"location":"#REPLSmuggler.Server.Session","page":"Home","title":"REPLSmuggler.Server.Session","text":"The session of a client.\n\n\n\n\n\n","category":"type"},{"location":"#REPLSmuggler.Server.Smuggler","page":"Home","title":"REPLSmuggler.Server.Smuggler","text":"Store the sessions of a server.\n\n\n\n\n\n","category":"type"},{"location":"#REPLSmuggler.Server.deserialize_requests-Tuple{REPLSmuggler.Server.Session, Any}","page":"Home","title":"REPLSmuggler.Server.deserialize_requests","text":"Dispatch repeatedly the incoming requests of a session.\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.Server.evaluate_entries-Tuple{Any}","page":"Home","title":"REPLSmuggler.Server.evaluate_entries","text":"evaluate_entries(session)\n\nRepeatedly evaluate the code put to the input channel of the session.\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.Server.evaluate_entry-NTuple{5, Any}","page":"Home","title":"REPLSmuggler.Server.evaluate_entry","text":"evaluate_entry(session, msgid, file, line, value)\n\nEvaluate the code in value in the context of the given session, replacing the context of the code with file and line. If an error occurs, it will put a  using Base: JuliaSyntax Protocols.Error to the outgoing channel of the session.\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.Server.getsession-Tuple{REPLSmuggler.Server.Smuggler}","page":"Home","title":"REPLSmuggler.Server.getsession","text":"getsession(smuggler)\n\nReturn a Session through a call to waitsession.\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.Server.serialize_responses-Tuple{Any}","page":"Home","title":"REPLSmuggler.Server.serialize_responses","text":"Send repeatedly the responses of a given session.\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.Server.serve_repl-Tuple{REPLSmuggler.Server.Smuggler}","page":"Home","title":"REPLSmuggler.Server.serve_repl","text":"Serve sessions to clients connecting to a server.\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.Server.serve_repl_session-Tuple{Any}","page":"Home","title":"REPLSmuggler.Server.serve_repl_session","text":"Serve one session, starting three loops to evaluate the entries, serialize the responses and deserialize the requests.\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.Server.sessions-Tuple{REPLSmuggler.Server.Smuggler}","page":"Home","title":"REPLSmuggler.Server.sessions","text":"Get the sessions.\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.Server.treatrequest","page":"Home","title":"REPLSmuggler.Server.treatrequest","text":"Fed to Protocols.dispatchonmessage to respond accordingly to incoming requests.\n\n\n\n\n\n","category":"function"},{"location":"#REPLSmuggler.Server.vessel-Tuple{REPLSmuggler.Server.Smuggler}","page":"Home","title":"REPLSmuggler.Server.vessel","text":"Get the vessel.\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.Server.waitsession-Tuple{T} where T","page":"Home","title":"REPLSmuggler.Server.waitsession","text":"Has to be implemented for each specific server. See for example SocketSmugglers.\n\nShould return the specific of a session used to build a Session.\n\n\n\n\n\n","category":"method"},{"location":"#Default-implementation","page":"Home","title":"Default implementation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [REPLSmuggler.MsgPackSerializer, REPLSmuggler.SocketSmugglers]","category":"page"},{"location":"#REPLSmuggler.MsgPackSerializer","page":"Home","title":"REPLSmuggler.MsgPackSerializer","text":"The default serializer for REPLSmuggler.jl\n\n\n\n\n\n","category":"module"},{"location":"#REPLSmuggler.SocketSmugglers","page":"Home","title":"REPLSmuggler.SocketSmugglers","text":"A specific kind of server for UNIX sockets / Windows pipes.\n\n\n\n\n\n","category":"module"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
