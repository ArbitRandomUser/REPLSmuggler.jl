var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = REPLSmuggler","category":"page"},{"location":"#REPLSmuggler","page":"Home","title":"REPLSmuggler","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for REPLSmuggler.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [REPLSmuggler, REPLSmuggler.Protocols]","category":"page"},{"location":"#REPLSmuggler.smuggle-Tuple{Any, Any}","page":"Home","title":"REPLSmuggler.smuggle","text":"smuggle(smuggler, args...; kwargs...)\n\nYou can start smuggling.\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.Protocols","page":"Home","title":"REPLSmuggler.Protocols","text":"Definition of the protocol used by REPLSmuggler.jl. It is based on MsgPack-RPC, see here:\n\nhttps://github.com/msgpack/msgpack/blob/master/spec.md\nhttps://github.com/msgpack-rpc/msgpack-rpc/blob/master/spec.md\n\nThe actual (de)serialization from and to MsgPack objects is handled by MsgPack.jl through a lightweight wrapper defined in MsgPackSerializer.jl.\n\nThe protocol consists of requests messages and their corresponding response messages. There can also be notification messages.\n\nAs per the specification, a request is serialized to an array of four elements, that could be written in Julia as follow:\n\n[type::UInt8, msgid::UInt32, method::String, params::Vector{Any}]\n\nWhere type = 0x00. For convenience, we define a structure and teach MsgPack.jl to serialize it.\n\nA response message should be serialized as:\n\n[type::UInt8, msgid::UInt32, error::Any, result::Any]\n\nWhere type = 0x01. msgid is the identifier of the corresponding request.\n\nFinally, a notification has the form:\n\n[type::UInt8, method::String, params::Vector{Any}]\n\nWhere type = 0x02.\n\nDefined methods for requests.\n\nWe allow the client to run the following methods. If a method is unknown by the server, it will raise an error.\n\neval: Evaluate a chunk of code. Parameters:\nfile::String\nline::UInt32\ncode::String\ninterrupt: Interrupt the current evaluation. No parameter.\nexit: Stop the current session. No parameter.\n\nResponses of the server.\n\nThe result field is a string of what would be printed in the REPL. It is empty if an error occured. \n\nIf an error occured, then the error field is a three-elements array structured as follow:\n\nexception::String: Name of the exception, e.g. \"ValueError\",\nexception_text::String: Text, e.g. \"This value cannot be < 0.\",\nstacktrace::Vector{Tuple{String, UInt32, String}}: The stacktrace, with each  row being (file, line, function).\n\nNotifications by the server.\n\nCurrently, the following notifications can be sent by the server. If a notification received by the client is unknown, it should simply be ignored without erroring.\n\nhandshake: Sent at the begining of a session, mainly to ensure the correct version of the protocol is being used. Parameters:\nmyname::String: Name of the server. Will typically be REPLSmuggler, but could be replaced if other implementations of the protocol were to exist.\nversion::String: A sementic versioning version number telling the client which version of the protocol is being used by the server.\n\nTypical session:\n\nThe client connects to the server.\nThe server sends a handshake notification.\nThe client checks it is running the correct version of the protocol.\nThe client runs requests (eval, interrupts...)\nThe server responds to the requests.\nThe client runs exit.\nThe server stops all the running code and close the session.\n\nNote that any interrupt of the connection (i.e. closing the socket) is equivalent to sending an exit request.\n\n\n\n\n\n","category":"module"},{"location":"#REPLSmuggler.Protocols.PROTOCOL_MAGIC","page":"Home","title":"REPLSmuggler.Protocols.PROTOCOL_MAGIC","text":"Name of the protocol implementation.\n\n\n\n\n\n","category":"constant"},{"location":"#REPLSmuggler.Protocols.PROTOCOL_VERSION","page":"Home","title":"REPLSmuggler.Protocols.PROTOCOL_VERSION","text":"Protocol version.\n\n\n\n\n\n","category":"constant"},{"location":"#REPLSmuggler.Protocols.AbstractMsgPackRPC","page":"Home","title":"REPLSmuggler.Protocols.AbstractMsgPackRPC","text":"Represents a MsgPackRPC message. type needs not to be stored explicitely.\n\n\n\n\n\n","category":"type"},{"location":"#REPLSmuggler.Protocols.AbstractResponse","page":"Home","title":"REPLSmuggler.Protocols.AbstractResponse","text":"Represents a response.\n\n\n\n\n\n","category":"type"},{"location":"#REPLSmuggler.Protocols.MsgType","page":"Home","title":"REPLSmuggler.Protocols.MsgType","text":"MsgPackRPC message types.\n\n\n\n\n\n","category":"type"},{"location":"#REPLSmuggler.Protocols.Notification","page":"Home","title":"REPLSmuggler.Protocols.Notification","text":"Represents a notification.\n\n\n\n\n\n","category":"type"},{"location":"#REPLSmuggler.Protocols.ProtocolException","page":"Home","title":"REPLSmuggler.Protocols.ProtocolException","text":"Used internally to report protocol exceptions.\n\n\n\n\n\n","category":"type"},{"location":"#REPLSmuggler.Protocols.Request","page":"Home","title":"REPLSmuggler.Protocols.Request","text":"Represents a request.\n\n\n\n\n\n","category":"type"},{"location":"#REPLSmuggler.Protocols.Error-Union{Tuple{T}, Tuple{Any, T, Any}} where T","page":"Home","title":"REPLSmuggler.Protocols.Error","text":"Error(msgid, error, stackframe)\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.Protocols.Handshake-Tuple{}","page":"Home","title":"REPLSmuggler.Protocols.Handshake","text":"Handshake()\n\nCreate a hand-shake notification.\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.Protocols.Result-Tuple{Any, Any}","page":"Home","title":"REPLSmuggler.Protocols.Result","text":"Result(msgid, result)\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.Protocols.astuple","page":"Home","title":"REPLSmuggler.Protocols.astuple","text":"astuple(message)\n\nReturns a vector from the message that can be serialized.\n\n\n\n\n\n","category":"function"},{"location":"#REPLSmuggler.Protocols.deserialize","page":"Home","title":"REPLSmuggler.Protocols.deserialize","text":"serialize(protocol)\n\nDe-serialize an AbstractMsgPackRPC. Must be implemented by the serializer, e.g. MsgPackSerializer.jl.\n\n\n\n\n\n","category":"function"},{"location":"#REPLSmuggler.Protocols.dispatchonmessage-Tuple{REPLSmuggler.Protocols.Protocol, Any, Vararg{Any}}","page":"Home","title":"REPLSmuggler.Protocols.dispatchonmessage","text":"dispatchonmessage(protocol, f, args...; kwargs)\n\nDeserialize a request, and send it to the correct method of f. f should define methods with a first parameter being of type Val{:method} where method can be: \"eval\", \"interrupt\", or \"exit\". f is called as:\n\nf(Val(method), args..., request.msgid, request.params...; kwargs...)\n\nA ProtocolException might be raised if the request is malformed.\n\n\n\n\n\n","category":"method"},{"location":"#REPLSmuggler.Protocols.serialize","page":"Home","title":"REPLSmuggler.Protocols.serialize","text":"serialize(protocol, message)\n\nSerialize an AbstractMsgPackRPC. Must be implemented by the serializer, e.g. MsgPackSerializer.jl.\n\n\n\n\n\n","category":"function"}]
}
